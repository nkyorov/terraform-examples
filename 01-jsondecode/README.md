# Using jsondecode to create resources
## Overview
JSON files allow you to separate the configuration data from the Terraform code, making it easier to manage, maintain, and update. The Terraform code remains focused on resource definitions and logic, while the JSON files handle the input data. As an added benefit, they can be dynamically generated by other systems or scripts

JSON files can be more intuitive for non-Terraform users who might need to review or modify configuration data. This can improve collaboration across teams by making the configuration data more accessible.

## Conversion
The Terraform language automatic type conversion rules mean that you don't usually need to worry about exactly what type is produced for a given value, and can just use the result in an intuitive way.

| JSON Type | Terraform Type                                               |
| --------- | ------------------------------------------------------------ |
| String    | `string`                                                     |
| Number    | `number`                                                     |
| Boolean   | `bool`                                                       |
| Object    | `object(...)` with attribute types determined per this table |
| Array     | `tuple(...)` with element types determined per this table    |
| Null      | The Terraform language `null` value                          |


## Validating JSON Schemas
`json-schema` can help you create a clear, standardized representation of your data to improve understanding and collaboration among developers, stakeholders, and collaborators. To catch and prevent errors, inconsistencies, and invalid data define constraints for your data structures.

You can validate a file against the schema by running:

```bash
$> check-jsonschema --schemafile schema.json instance.json
```

You can add this as a step to your `pre-commit` hooks and/or to your Quality Checks for Pull Requests.

```yaml
- repo: https://github.com/python-jsonschema/check-jsonschema
  rev: 0.29.2
  hooks:
    - id: check-jsonschema
      name: Validate Test Configs
      args: ["--schemafile", "path/to/your/schema/file"]
      files: ^instance.json$
```

## Examples
### enum
The **enum** keyword is used to restrict a value to a fixed set of values. It must be an array with at least one element, where each element is unique. In `resource_group.schema.json`. the only allowed value for `Environment` is `dev`.

```json
{
  "name" : "rg-jsondecode-test",
  "location" : "westeurope",
  "tags" : {
    "Environment" : "tst",
    "ChargeCode" : "B135123"
  }
}

$> check-jsonschema --schemafile resource_group.schema.json resource_group.json
Schema validation errors were encountered.
  resource_group.json::$.tags.Environment: 'tst' is not one of ['dev']
```
### Regex
You can also use regular expressions to express constraints, or constrain the instance value to be a regular expression with the `pattern` field.

```json
{
  "name" : "rg-jsondecode-test",
  "location" : "westeurope",
  "tags" : {
    "Environment" : "dev",
    "ChargeCode" : "STS-123456"
  }
}

$> check-jsonschema --schemafile resource_group.schema.json resource_group.json
ok -- validation done
```

### Optional values
We can skip values by ommiting them from the `required` field.
```json
{
  "name" : "rg-jsondecode-test",
  "location" : "westeurope",
  "tags" : {
    "Environment" : "dev"
  }
}

$> check-jsonschema --schemafile resource_group.schema.json resource_group.json
ok -- validation done
```

We can also skip entire objects.
```json
{
  "name" : "rg-jsondecode-test",
  "location" : "westeurope"
}

$> check-jsonschema --schemafile resource_group.schema.json resource_group.json
ok -- validation done
```